### Sdl2 window backend for egui

### Emscripten 
you will need to add this link flags to your build process.
I just put all of them here, but choose what you need.
```toml
# inside .cargo/config.toml
[target.wasm32-unknown-emscripten]
rustflags = [
    "-C",
    "link-arg=-s",
    "-C",
    "link-arg=USE_GLFW=3", # for glfw support. 
    "-C",
    "link-arg=-s",
    "-C",
    "link-arg=FULL_ES2",# for opengl es 2 emulation
    "-C",
    "link-arg=-s",
    "-C",
    "link-arg=FULL_ES3", # for opengl es 3 emulation
    "-C",
    "link-arg=-s",
    "-C",
    "link-arg=USE_SDL=2", # for sdl2. 
    "-C",
    "link-arg=-s",
    "-C",
    "link-arg=MAX_WEBGL_VERSION=2 ", # to make sure that webgl2 is enabled. 
    "-C",
    "link-arg=-s",
    "-C",
    "link-arg=MIN_WEBGL_VERSION=2", # to disable webgl1 completely, and use webgl2 exclusively. 
    "-C",
    "link-arg=-s",
    "-C",
    "link-arg=DISABLE_DEPRECATED_FIND_EVENT_TARGET_BEHAVIOR=1", # i don't even remember why i have this :D.
]
```
on emscripten target, sdl2 crate will set raw window handle id to `1` by hardcoding it. reference: https://github.com/Rust-SDL2/rust-sdl2/blob/master/src/sdl2/raw_window_handle.rs#L18
so, make sure that the relevant `data-raw-handle` property value on canvas to `1`.

example html to use for your sdl2 wasm app:
```html
<!DOCTYPE html>
<html>
  <body>
    <canvas data-raw-handle="1" id="canvas"></canvas>
    <!-- you need this script to actually let sdl2 library find the canvas for backing its window -->
    <script type="text/javascript">
      var Module = {
        canvas: (function () {
          // this is how we provide a canvas to our sdl2
          return document.getElementById("canvas");
        })(),
      };
    </script>
    <!-- the above scrit MUST BE loaded before the below generated by cargo. so, don't change the order of these tags -->
    <script src="rust-sdl2-wasm.js"></script>
  </body>
</html>
```
script to build and deploy
```sh
#!/bin/sh
echo "building for emscripten target"
# make sure that cargo use using the config file that has all the sdl2 linker options
cargo build --target=wasm32-unknown-emscripten --release
echo "copying files to dist directory"
# the directory can be anything temporary within which you want to place your server files
mkdir -p dist
# wasm file is obviously your rust binary
cp target/wasm32-unknown-emscripten/release/rust_sdl2_wasm.wasm dist
# but as the above binary needs to interact with browser via js, 
# this helper js script is generated by cargo to load and support the rust wasm binary
cp target/wasm32-unknown-emscripten/release/rust-sdl2-wasm.js dist
# just the above html file
cp index.html dist
echo "launching server using python http.server on http://127.0.0.1:8000/"
# a temporary server to use for local development. DON"T USE IN PRODUCTION!!!
(cd dist && python -m http.server --bind 127.0.0.1)
```

this is basically the setup needed for emscripten. use the `set_main_loop_callback` function shown below, to call that static closure every frame. 
THIS IS DONE AUTOMATICALLY inside sdl2's `run_event_loop` function. I am just pasting this here for completion.

example main.rs:
```rust

#[allow(non_camel_case_types)]
type em_callback_func = unsafe extern "C" fn();

extern "C" {
    // This extern is built in by Emscripten.
    pub fn emscripten_run_script_int(x: *const std::ffi::c_uchar) -> std::ffi::c_int;
    pub fn emscripten_cancel_main_loop();
    pub fn emscripten_set_main_loop(
        func: em_callback_func,
        fps: std::ffi::c_int,
        simulate_infinite_loop: std::ffi::c_int,
    );
}

thread_local!(static MAIN_LOOP_CALLBACK: std::cell::RefCell<Option<Box<dyn FnMut()>>>  = std::cell::RefCell::new(None));

pub fn set_main_loop_callback<F: 'static>(callback: F)
where
    F: FnMut(),
{
    MAIN_LOOP_CALLBACK.with(|log| {
        *log.borrow_mut() = Some(Box::new(callback));
    });

    unsafe {
        emscripten_set_main_loop(wrapper::<F>, 0, 1);
    }

    extern "C" fn wrapper<F>()
    where
        F: FnMut(),
    {
        MAIN_LOOP_CALLBACK.with(|z| {
            if let Some(ref mut callback) = *z.borrow_mut() {
                callback();
            }
        });
    }
}
```